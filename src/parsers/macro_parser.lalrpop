grammar;

use crate::*;

// pub LightFile: (Option<Vec<Instance>>, Option<Vec<CheckUtxo>>, Option<Vec<String>>) = {
//     <instances: Instance*> <check_utxos: CheckUtxoType*> <circom_code: CIRCOM_CODE*> => 
//         (if instances.is_empty() { None } else { Some(instances) }, 
//          if check_utxos.is_empty() { None } else { Some(check_utxos) },
//          if circom_code.is_empty() { None } else { Some(circom_code.into_iter().map(ToString::to_string).collect()) })
// };
// 
// pub CircomCode: Vec<String> = {
//     <token: CIRCOM_CODE*> => token.into_iter().map(ToString::to_string).collect()
// };

pub LightFile: (Option<Vec<Instance>>, Option<Vec<CheckUtxo>>) = {
    <instances: Instance*> <check_utxos: CheckUtxoType*> => 
        (if instances.is_empty() { None } else { Some(instances) }, 
         if check_utxos.is_empty() { None } else { Some(check_utxos) })
};


// Main rule for parsing the Instance struct
pub Instance: Instance = {
    "#[instance]" "{" <def:InstanceFields> "}" => def
};

InstanceFields: Instance = {
    <file_name:FileNameProperty> ","
    <config:ConfigProperty>
    <public_inputs:PublicInputsProperty> => 
        Instance {
            file_name: file_name,
            config: config,
            public_inputs: public_inputs,
            template_name: None,
        }
};

// ... Continue with other rules if needed

SeparatedCommaString: Vec<String> = {
    <head: STRING> <tail:("," STRING)*> => {
        let mut vec = vec![head.to_string()];
        vec.extend(tail.into_iter().map(|(_, item)| item.to_string()));
        vec
    }
};

FileNameProperty: String = 
    <kv:KeyValuePair> => {
        if kv.0 == "fileName" {
            kv.1.to_string()
        } else {
            panic!("Expected 'fileName', got {}", kv.0)
        }
    };

ConfigProperty: Option<Vec<String>> = {
    "config:" "(" <strings: SeparatedCommaString> ")" "," => Some(strings),
    () => None
};


PublicInputsProperty: Vec<String> = {
    "publicInputs:" "[" <inputs: SeparatedCommaString> "]" "," => {
        let mut default_inputs = vec![
            String::from("transactionHash"),
            String::from("publicAppVerifier"),
        ];
        let mut combined = if inputs.is_empty() {
            Vec::<String>::new()
        } else {
            inputs
        };
        default_inputs.append(&mut combined);
        default_inputs
    },
    () => vec![
        String::from("transactionHash"),
        String::from("publicAppVerifier"),
    ]
};


KeyValuePair: (String, String) = 
    <key:STRING> ":" <value:ValueString> => (key.to_string(), value.to_string());

ValueString: String = <s:STRING> => s.to_string();


match {
    r"\s*" => { }, // whitespace
    r"//[^\n\r]*[\n\r]*" => {}, // single line comments
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => {}, // multi-line comments
    r###"pragma\s+[^;]*;|include\s+"[^"]+";|template\s+\w+\(\)\s*\{\s*[^}]*\}|#\[lightTransaction\s*\(\s*[^\]]+\s*\)\]"### => {}, //CIRCOM_CODE
    r"#\[instance\]" => "#[instance]",
    r"#\[" => "#[",
    r"\[" => "[",
    r"\]" => "]",
    r"\{" => "{",
    r"\}" => "}",
    r"\(" => "(",
    r"\)" => ")",
    r"\)\]" => ")]",
    r":" => ":",
    r"," => ",",
    r"publicInputs:" => "publicInputs:",
    r"#\[checkInUtxo\(?" => "#[checkInUtxo(",
    r"#\[checkOutUtxo\(?" => "#[checkOutUtxo(",
    r"amountSol " => "amountSol ",
    r"amountSpl " => "amountSpl ",
    r"appDataHash " => "appDataHash ",
    r"utxoData:" => "utxoData:",
    r"assetSpl " => "assetSpl ",
    r"==" => "==",
    r"!=" => "!=",
    r">" => ">",
    r"<" => "<",
    r">=" => ">=",
    r"<=" => "<=",
    r"config:" => "config:",
    r"-?[a-zA-Z_0-9]+" => STRING
}

// pub CheckUtxos: Vec<CheckUtxo> = {
//     <utxos: CheckUtxoType*> => utxos
// };

pub CheckUtxoType: CheckUtxo = {
    "#[checkInUtxo(" <name:STRING> "," <no_utxos:STRING> "," <instruction:STRING> ")]"* <fields:CheckUtxoFields> => {
        CheckUtxo {
            code: "".to_string(), 
            name: name.to_string(),
            is_in_utxo: true,
            is_out_utxo: false,
            instruction_name: Some(instruction.to_string()),
            no_utxos: no_utxos.to_string(),
            amount_sol: fields.0,
            amount_spl: fields.1,
            asset_spl: fields.2,
            app_data_hash: fields.3,
            utxo_data: fields.4,
        }
    },
    "#[checkOutUtxo(" <name:STRING> "," <no_utxos:STRING> "," <instruction:STRING> ")]" <fields:CheckUtxoFields> => {
        CheckUtxo {
            code: "".to_string(),
            name: name.to_string(),
            is_in_utxo: false,
            is_out_utxo: true,
            instruction_name: Some(instruction.to_string()),
            no_utxos: no_utxos.to_string(),
            amount_sol: fields.0,
            amount_spl: fields.1,
            asset_spl: fields.2,
            app_data_hash: fields.3,
            utxo_data: fields.4,
        }
    }
};

CheckUtxoFields: (Option<(Comparator, String)>, Option<(Comparator, String)>, Option<(Comparator, String)>, Option<(Comparator, String)>, Option<Vec<(String, Option<Comparator>, Option<String>)>>) = {
    "{" <amount_sol:AmountSolProperty> <amount_spl:AmountSplProperty> <asset_spl:AssetSplProperty> <app_data_hash:AppDataHashProperty> <utxo_data:UtxoDataProperty> "}" => (amount_sol, amount_spl, asset_spl, app_data_hash, utxo_data)
};

AmountSolProperty: Option<(Comparator, String)> = {
    "amountSol " <comparator:COMPARATOR> <value:STRING> "," => Some((comparator, value.to_string())),
    () => None
};

AmountSplProperty: Option<(Comparator, String)> = {
    "amountSpl " <comparator:COMPARATOR> <value:STRING> "," => Some((comparator, value.to_string())),
    () => None
};

AssetSplProperty: Option<(Comparator, String)> = {
    "assetSpl " <comparator:COMPARATOR> <value:STRING> "," => Some((comparator, value.to_string())),
    () => None
};

AppDataHashProperty: Option<(Comparator, String)> = {
    "appDataHash " <comparator:COMPARATOR> <value:STRING> "," => Some((comparator, value.to_string())),
    () => None
};

UtxoDataProperty: Option<Vec<(String, Option<Comparator>, Option<String>)>> = {
    "utxoData:" "{" <fields:UtxoDataFields> "}" => Some(fields),
    () => None
};

UtxoDataFields: Vec<(String, Option<Comparator>, Option<String>)> = {
    <fields: UtxoDataField*> => fields
};

UtxoDataField: (String, Option<Comparator>, Option<String>) = {
    <attribute:STRING> "," => (attribute.to_string(), None, None),
    <attribute:STRING> <comparator:COMPARATOR> <comparison_value:STRING> "," => (attribute.to_string(), Some(comparator), Some(comparison_value.to_string()))
};




COMPARATOR: Comparator = {
    "==" => Comparator::Equal,
    "!=" => Comparator::NotEqual,
    ">" => Comparator::GreaterThan,
    "<" => Comparator::LessThan,
    ">=" => Comparator::GreaterEqualThan,
    "<=" => Comparator::LessEqualThan
};
