use std::{
    fs::{self, File},
    io::prelude::*,
};
extern crate syn;
use crate::{checkUtxo::CheckUtxo, Instance};

pub const AUTO_GENERATED_ACCOUNTS_TEMPLATE: &str = "use anchor_lang::prelude::*;

/**
 * This file is auto-generated by the Light cli.
 * DO NOT EDIT MANUALLY.
 * THE FILE WILL BE OVERWRITTEN EVERY TIME THE LIGHT CLI BUILD IS RUN.
 */
    #[allow(non_camel_case_types)]
    // helper struct to create anchor idl with u256 type
    #[account]
    #[derive(Debug, Copy, PartialEq)]
    pub struct u256 {
        pub x: [u8; 32],
    }
 ";

const UTXO_STRUCT_BASE: &str = "\
#[allow(non_snake_case)]
#[derive(Debug, Copy, PartialEq)]
#[account]
pub struct Utxo {
    pub amounts: [u64; 2],
    pub spl_asset_index: u64,
    pub verifier_address_index: u64,
    pub blinding: u256,
    pub app_data_hash: u256,
    pub account_shielded_public_key: u256,
    pub account_encryption_public_key: [u8; 32],";

const PUBLIC_INPUTS_INSTRUCTION_DATA_BASE: &str = "#[allow(non_snake_case)]
#[derive(Debug)]
#[account]
pub struct InstructionDataLightInstructionSecond {";

pub const UTXO_APP_DATA_STRUCT_BASE: &str = "#[allow(non_snake_case)]
#[account]
#[derive(Debug, Copy, PartialEq)]
pub struct UtxoAppData {";

pub fn create_rust_idl(base: &str, public_inputs: &Vec<String>, input_type: &str) -> String {
    let mut result = String::from(base);

    for input in public_inputs {
        result = format!("{}\n    pub {}: {},", result, input, input_type);
    }

    result.push_str("\n}");
    result
}

fn create_light_utils_str(
    utxo_rust_idl_string: String,
    public_inputs_rust_idl_string: String,
    utxo_app_data_rust_idl_string: String,
    instance: Instance,
) -> String {
    let mut result = String::from(AUTO_GENERATED_ACCOUNTS_TEMPLATE);
    let nr_public_inputs = format!(
        "pub const NR_CHECKED_INPUTS: usize = {};",
        instance.public_inputs.len()
    );
    result = format!("{}\n{}\n", result, nr_public_inputs);
    result = format!("{}\n{}\n", result, public_inputs_rust_idl_string);
    result = format!("{}\n{}\n", result, utxo_rust_idl_string);
    result = format!("{}\n{}\n", result, utxo_app_data_rust_idl_string);
    result
}

fn gen_code_auto_generated_accounts(
    instance: Instance,
    checked_in_utxos: Vec<CheckUtxo>,
) -> String {
    let utxo_data_variable_names = checked_in_utxos[0]
        .clone()
        .utxo_data
        .unwrap_or(vec![])
        .iter()
        .map(|u| u.0.clone())
        .collect::<Vec<String>>();
    let utxo_rust_idl_string = create_rust_idl(UTXO_STRUCT_BASE, &utxo_data_variable_names, "u256");
    let public_inputs_rust_idl_string = create_rust_idl(
        PUBLIC_INPUTS_INSTRUCTION_DATA_BASE,
        &instance.public_inputs[..instance.public_inputs.len() - 2].to_vec(),
        "[u8; 32]",
    );
    let utxo_app_data_rust_idl_string =
        create_rust_idl(UTXO_APP_DATA_STRUCT_BASE, &utxo_data_variable_names, "u256");

    create_light_utils_str(
        utxo_rust_idl_string,
        public_inputs_rust_idl_string,
        utxo_app_data_rust_idl_string,
        instance,
    )
}

pub fn gen_code_auto_generated_accounts_file(
    program_name: String,
    instance: Instance,
    checked_in_utxos: Vec<CheckUtxo>,
) {
    let code = gen_code_auto_generated_accounts(instance, checked_in_utxos);
    let path = "./programs/".to_owned() + &program_name + "/src/auto_generated_accounts.rs";
    write_code_to_file(path, code);
}

pub fn write_code_to_file(path: String, code: String) {
    let code = crate::rustfmt(code).unwrap();
    let mut output_file_idl = fs::File::create(path).unwrap();
    output_file_idl.write(&code).unwrap();
    // write!(&mut output_file_idl, "{}", code).unwrap();
}

#[cfg(test)]
mod auto_generated_accounts_tests {
    use super::*;
    use quote::ToTokens;
    use syn::Item;
    /// Asserts that two Rust code strings are equivalent by parsing them with `syn` and comparing the token streams.
    fn assert_syn_eq(output: &str, expected_output: &str) {
        let parsed_output: Item = syn::parse_str(output).expect("Failed to parse output");
        let parsed_expected: Item =
            syn::parse_str(expected_output).expect("Failed to parse expected output");

        let output_tokens = parsed_output.into_token_stream().to_string();
        let expected_tokens = parsed_expected.into_token_stream().to_string();

        assert_eq!(output_tokens, expected_tokens);
    }

    #[test]
    fn test_create_utxo_rust_idl_success() {
        let public_inputs = vec![String::from("release_slot"), String::from("other_slot")];
        let result = create_rust_idl(UTXO_STRUCT_BASE, &public_inputs, "u256");

        let expected_output = "#[allow(non_snake_case)]
            #[derive(Debug, Copy, PartialEq)]
            #[account]
            pub struct Utxo {
            pub amounts: [u64; 2],
            pub spl_asset_index: u64,
            pub verifier_address_index: u64,
            pub blinding: u256,
            pub app_data_hash: u256,
            pub account_shielded_public_key: u256,
            pub account_encryption_public_key: [u8; 32],
            pub release_slot: u256,
            pub other_slot: u256,
            }";

        assert_syn_eq(result.as_str(), expected_output);
    }

    #[test]
    fn test_create_rust_idl() {
        let public_inputs = vec![String::from("current_slot"), String::from("other_slot")];
        let output = create_rust_idl(PUBLIC_INPUTS_INSTRUCTION_DATA_BASE, &public_inputs, "u256");

        let expected_output = "#[allow(non_snake_case)]
            #[derive(Debug)]
            #[account]
            pub struct InstructionDataLightInstructionSecond {
            pub current_slot: u256,
            pub other_slot: u256,
        }";
        assert_syn_eq(output.as_str(), expected_output);
    }
}
