use handlebars::Handlebars;
use serde_json::json;
use std::{
    fs::{self},
    io::prelude::*,
};
extern crate syn;
use crate::{checkUtxo::CheckUtxo, Instance};

pub const AUTO_GENERATED_ACCOUNTS_TEMPLATE: &str = "
use anchor_lang::prelude::*;

/**
 * This file is auto-generated by the Light cli.
 * DO NOT EDIT MANUALLY.
 * THE FILE WILL BE OVERWRITTEN EVERY TIME THE LIGHT CLI BUILD IS RUN.
 */
#[allow(non_camel_case_types)]
// helper struct to create anchor idl with u256 type
#[account]
#[derive(Debug, Copy, PartialEq)]
pub struct u256 {
    pub x: [u8; 32],
}

pub const NR_CHECKED_INPUTS: usize = {{nr_checked_inputs}};

#[allow(non_snake_case)]
#[derive(Debug)]
#[account]
pub struct InstructionDataLightInstructionSecond {
    {{#each public_inputs}}
    pub {{this}}: [u8; 32],
    {{/each}}
}

#[allow(non_snake_case)]
#[derive(Debug, Copy, PartialEq)]
#[account]
pub struct Utxo {
    pub amounts: [u64; 2],
    pub spl_asset_index: u64,
    pub verifier_address_index: u64,
    pub blinding: u256,
    pub app_data_hash: u256,
    pub account_shielded_public_key: u256,
    pub account_encryption_public_key: [u8; 32],
    {{#each utxo_inputs}}
    pub {{this}}: u256,
    {{/each}}
}

#[allow(non_snake_case)]
#[account]
#[derive(Debug, Copy, PartialEq)]
pub struct UtxoAppData {
    {{#each utxo_inputs}}
    pub {{this}}: u256,
    {{/each}}
}";
// TODO: reflect utxo name in the template
// TODO: reflect whether it's in or out utxo in the template
fn gen_code_auto_generated_accounts(
    instance: Instance,
    checked_in_utxos: Vec<CheckUtxo>,
) -> String {
    let utxo_data_variable_names = checked_in_utxos[0]
        .clone()
        .utxo_data
        .unwrap_or(vec![])
        .iter()
        .map(|u| u.0.clone())
        .collect::<Vec<String>>();

    let public_inputs = instance.public_inputs[..instance.public_inputs.len() - 2].to_vec();
    let handlebars = Handlebars::new();
    let data = json!({
        "nr_checked_inputs": instance.public_inputs.len().to_string(),
        "utxo_inputs": utxo_data_variable_names,
        "public_inputs": public_inputs
    });

    handlebars
        .render_template(AUTO_GENERATED_ACCOUNTS_TEMPLATE, &data)
        .unwrap_or_default()
}

pub fn gen_code_auto_generated_accounts_file(
    program_name: String,
    instance: Instance,
    checked_in_utxos: Vec<CheckUtxo>,
) {
    let code = gen_code_auto_generated_accounts(instance, checked_in_utxos);
    let path = "./programs/".to_owned() + &program_name + "/src/auto_generated_accounts.rs";
    write_code_to_file(path, code);
}

pub fn write_code_to_file(path: String, code: String) {
    let code = crate::rustfmt(code).unwrap();
    let mut output_file_idl = fs::File::create(path).unwrap();
    output_file_idl.write(&code).unwrap();
    // write!(&mut output_file_idl, "{}", code).unwrap();
}

#[cfg(test)]
mod auto_generated_accounts_tests {
    use super::*;
    use quote::ToTokens;
    /// Asserts that two Rust code strings are equivalent by parsing them with `syn` and comparing the token streams.
    fn assert_syn_eq(output: &str, expected_output: &str) {
        let parsed_output: syn::File =
            syn::parse_str(output).expect("Failed to parse expected output");
        let parsed_expected: syn::File =
            syn::parse_str(expected_output).expect("Failed to parse expected output");

        let output_tokens = parsed_output.into_token_stream().to_string();
        let expected_tokens = parsed_expected.into_token_stream().to_string();

        assert_eq!(output_tokens, expected_tokens);
    }

    #[test]
    fn test_functional() {
        let file_path = "./tests/test-files/test-data-psp/auto_generated_accounts.rs";
        let mut file = File::open(file_path).expect("Unable to open the file");

        // Read the file's content
        let mut expected_output = String::new();
        file.read_to_string(&mut expected_output)
            .expect("Unable to read the file");

        let output = gen_code_auto_generated_accounts(
            Instance {
                public_inputs: vec![
                    String::from("publicZ"),
                    String::from("transactionHash"),
                    String::from("publicAppVerifier"),
                ],
                file_name: "random".to_string(),
                template_name: None,
                config: None,
            },
            vec![CheckUtxo {
                utxo_data: Some(vec![
                    (String::from("x"), None, None),
                    (String::from("y"), None, None),
                ]),
                code: "".to_string(),
                name: "".to_string(),
                is_in_utxo: true,
                is_out_utxo: false,
                instruction_name: None,
                no_utxos: "1".to_string(),
                amount_sol: None,
                amount_spl: None,
                asset_spl: None,
                app_data_hash: None,
            }],
        );
        assert_syn_eq(output.as_str(), expected_output.as_str());
    }
}
