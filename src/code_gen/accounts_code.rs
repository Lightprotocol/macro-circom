use handlebars::Handlebars;
use serde_json::json;

extern crate syn;
use crate::code_gen::check_utxo_code::CheckUtxo;
use crate::code_gen::circom_main_code::Instance;

pub const AUTO_GENERATED_ACCOUNTS_TEMPLATE: &str = "
use anchor_lang::prelude::*;

/**
 * This file is auto-generated by the Light cli.
 * DO NOT EDIT MANUALLY.
 * THE FILE WILL BE OVERWRITTEN EVERY TIME THE LIGHT CLI BUILD IS RUN.
 */
#[allow(non_camel_case_types)]
// helper struct to create anchor idl with u256 type
#[account]
#[derive(Debug, Copy, PartialEq)]
pub struct u256 {
    pub x: [u8; 32],
}

pub const NR_CHECKED_INPUTS: usize = {{nr_checked_inputs}};

#[allow(non_snake_case)]
#[derive(Debug)]
#[account]
pub struct InstructionDataLightInstructionSecond {
    {{#each public_inputs}}
    pub {{this}}: [u8; 32],
    {{/each}}
}

#[allow(non_snake_case)]
#[derive(Debug, Copy, PartialEq)]
#[account]
pub struct Utxo {
    pub amounts: [u64; 2],
    pub spl_asset_index: u64,
    pub verifier_address_index: u64,
    pub blinding: u256,
    pub app_data_hash: u256,
    pub account_shielded_public_key: u256,
    pub account_encryption_public_key: [u8; 32],
    {{#each utxo_inputs}}
    pub {{this}}: u256,
    {{/each}}
}

#[allow(non_snake_case)]
#[account]
#[derive(Debug, Copy, PartialEq)]
pub struct UtxoAppData {
    {{#each utxo_inputs}}
    pub {{this}}: u256,
    {{/each}}
}";

// TODO: reflect utxo name in the template
// TODO: reflect whether it's in or out utxo in the template
pub fn generate_accounts_code(instance: &Instance, checked_in_utxos: &Vec<CheckUtxo>) -> String {
    let utxo_data_variable_names = checked_in_utxos[0]
        .clone()
        .utxo_data
        .unwrap_or(vec![])
        .iter()
        .map(|u| u.0.clone())
        .collect::<Vec<String>>();

    let public_inputs = instance.public_inputs[..instance.public_inputs.len() - 2].to_vec();
    let handlebars = Handlebars::new();
    let data = json!({
        "nr_checked_inputs": instance.public_inputs.len().to_string(),
        "utxo_inputs": utxo_data_variable_names,
        "public_inputs": public_inputs
    });

    handlebars
        .render_template(AUTO_GENERATED_ACCOUNTS_TEMPLATE, &data)
        .unwrap_or_default()
}

#[cfg(test)]
mod auto_generated_accounts_tests {
    use super::*;
    use crate::utils::assert_syn_eq;
    use std::{fs::File, io::prelude::*};
    #[test]
    fn test_functional() {
        let file_path = "./tests/test-files/test-data-psp/auto_generated_accounts.rs";
        let mut file = File::open(file_path).expect("Unable to open the file");

        // Read the file's content
        let mut expected_output = String::new();
        file.read_to_string(&mut expected_output)
            .expect("Unable to read the file");

        let output = generate_accounts_code(
            &Instance {
                public_inputs: vec![
                    String::from("publicZ"),
                    String::from("transactionHash"),
                    String::from("publicAppVerifier"),
                ],
                file_name: "random".to_string(),
                template_name: None,
                config: None,
            },
            &vec![CheckUtxo {
                utxo_data: Some(vec![
                    (String::from("x"), None, None),
                    (String::from("y"), None, None),
                ]),
                code: "".to_string(),
                name: "".to_string(),
                is_in_utxo: true,
                is_out_utxo: false,
                instruction_name: None,
                no_utxos: "1".to_string(),
                amount_sol: None,
                amount_spl: None,
                asset_spl: None,
                app_data_hash: None,
                pool_type: None,
                verifier_address: None,
                tx_version: None,
                blinding: None,
            }],
        );
        assert_syn_eq(output.as_str(), expected_output.as_str());
    }
}
