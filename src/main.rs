pub mod code_gen;
pub mod errors;
pub mod parsers;
pub mod utils;
use crate::code_gen::{
    accounts_code::generate_accounts_code, check_utxo_code::*,
    circom_code::generate_psp_circom_code, circom_main_code::generate_circom_main_code,
    circom_main_code::Instance,
};

use anyhow::Error as AnyhowError;
use clap::{App, Arg};
use parsers::macro_parser;
use utils::{create_file, describe_error, open_file, write_rust_code_to_file};

// get instance
// - public inputs

// get utxo data
// - auto generate utxo hash code

// get light transaction
//      -expand template line
// - insert boilerplate code
// - insert utxo hash code

// Outputs:
// - circom file with circuit
// TODO: rust file with public inputs, sytem publicAppVerifier, as anchor constants

use std::path::Path;

fn remove_filename_suffix(input: &str) -> Result<(String, String), &'static str> {
    let path = Path::new(input);

    if path.extension() != Some(std::ffi::OsStr::new("light")) {
        return Err("The file does not have a .light suffix");
    }

    let directory = path
        .parent()
        .map_or(input, |p| p.to_str().unwrap_or(input))
        .to_string();
    let filename_without_suffix = path
        .file_stem()
        .map_or("", |f| f.to_str().unwrap_or(""))
        .to_string();
    println!("directory: {}", directory);
    println!("filename_without_suffix: {}", filename_without_suffix);
    Ok((directory, filename_without_suffix))
}

// throw error when no utxoData -> doesn't make sense
// throw error if is declared twice
// throw error when there is no #[instance]
// throw error when there is no #[lightTransaction(verifierTwo)]
// add test for no config inputs
/*
* Structure:
* - get instance (returns struct with file name, template name, config, public inputs)
* - get checkedUtxos (returns structs with code and utxo data)
* - get light transaction body
* - generate circom file
*/

fn main() -> Result<(), AnyhowError> {
    let matches = App::new("macro-circom")
        .version("0.1")
        .arg(
            Arg::with_name("file_path")
                .help("Path to the file")
                .required(true)
                .index(1),
        )
        .arg(
            Arg::with_name("program_name")
                .help("Name of the program")
                .required(true)
                .index(2),
        )
        .arg(
            Arg::with_name("output_accounts_path")
                .long("output_accounts_path")
                .help("Output path of the accounts rust file")
                .takes_value(true),
        )
        .arg(
            Arg::with_name("output_circom_path")
                .long("output_circom_path")
                .help("Output path of the generated circom and main circom files")
                .takes_value(true),
        )
        .get_matches();

    // Get the values of the arguments
    let file_path = matches.value_of("file_path").unwrap();
    let program_name = matches.value_of("program_name").unwrap();
    let output_accounts_path = matches.value_of("output_accounts_path");
    let output_circom_path = matches.value_of("output_circom_path");

    let (path_to_parent_dir, file_name) = remove_filename_suffix(file_path).unwrap();
    let contents = open_file(file_path)?;

    // parse .light file
    let (instance, mut checked_utxos, parsed_circom_code) = parse(contents.clone())?;
    let mut instance = instance[0].clone();
    // start code generation
    let (circom_main_code, circom_code, rust_autogenerated_accounts_code) =
        generate_code(&mut instance, &mut checked_utxos, parsed_circom_code);

    // create files
    create_files(
        circom_main_code,
        circom_code,
        rust_autogenerated_accounts_code,
        path_to_parent_dir,
        file_name,
        program_name.to_string(),
        output_accounts_path,
        output_circom_path,
    );
    Ok(())
}

fn parse(contents: String) -> Result<(Vec<Instance>, Vec<CheckUtxo>, String), AnyhowError> {
    let remaining_contents =
        match crate::parsers::circom_parser::CircomCodeParser::new().parse(&contents) {
            Ok(instance) => instance,
            Err(error) => {
                panic!("{}", describe_error(&contents, error));
            }
        };
    let parsing_res = match crate::macro_parser::LightFileParser::new().parse(&contents) {
        Ok(instance) => instance,
        Err(error) => {
            println!("Parsing check utxo error.");
            panic!("{}", describe_error(&contents, error));
        }
    };
    let instance = match parsing_res.0 {
        Some(instance) => instance,
        None => {
            println!("Parsing check utxo error.");
            panic!("No instance found.");
        }
    };
    let checked_utxos = match parsing_res.1 {
        Some(checked_utxos) => checked_utxos,
        None => Vec::<CheckUtxo>::new(),
    };

    // let (remaining_contents, checked_utxos) = generate_check_utxo_code(&contents)?;
    Ok((instance, checked_utxos, remaining_contents.join("\n")))
}

fn generate_code(
    instance: &mut Instance,
    checked_utxos: &mut Vec<CheckUtxo>,
    content: String,
) -> (String, String, String) {
    generate_check_utxo_code(checked_utxos).unwrap();
    let circom_main_code = generate_circom_main_code(&instance, &instance.file_name);
    let rust_autogenerated_accounts_code = generate_accounts_code(instance, &checked_utxos);

    let (_verifier_name, circom_code) =
        generate_psp_circom_code(&content, &checked_utxos, instance).unwrap();
    (
        circom_main_code,
        circom_code,
        rust_autogenerated_accounts_code,
    )
}

fn create_files(
    circom_main_code: String,
    circom_code: String,
    rust_autogenerated_accounts_code: String,
    path_to_parent_dir: String,
    file_name: String,
    program_name: String,
    provided_accounts_path: Option<&str>,
    provided_circom_path: Option<&str>,
) {
    let path_to_parent_dir = provided_circom_path
        .map(|s| s.to_string())
        .unwrap_or(path_to_parent_dir);

    let circuit_main_file_name = format!("{}/{}_main.circom", &path_to_parent_dir, &file_name);
    create_file(&circuit_main_file_name, &circom_main_code).unwrap();

    let circuit_file_name = format!("{}/{}.circom", &path_to_parent_dir, &file_name);
    create_file(&circuit_file_name, &circom_code).unwrap();

    let accounts_path = provided_accounts_path
        .map(|s| format!("{}/auto_generated_accounts.rs", &s))
        .unwrap_or(format!(
            "./programs/{}/src/auto_generated_accounts.rs",
            &program_name
        ));
    write_rust_code_to_file(accounts_path, rust_autogenerated_accounts_code);
}

#[cfg(test)]
mod tests {
    use std::process::Command;

    use super::*;
    #[test]
    fn test_parser() {
        let file_path = "./tests/test-files/test-data-psp/test_data.light";
        let content = open_file(file_path).unwrap();
        match macro_parser::LightFileParser::new().parse(content.as_str()) {
            Ok(instance) => instance,
            Err(error) => {
                println!("Parsing check utxo error.");
                panic!("{}", describe_error(&content, error));
            }
        };
    }

    #[test]
    fn test_main_functional() {
        let file_path = "./tests/test-files/test-data-psp/test_data.light";
        let program_name = "test_data";
        let command_output = Command::new("./target/debug/macro-circom")
            .args(&[
                file_path,
                program_name,
                "--output_accounts_path",
                "./target",
                "--output_circom_path",
                "./target",
            ])
            .output()
            .expect("Failed to execute command");
        let stdout = String::from_utf8_lossy(&command_output.stdout);
        println!("Command output (stdout):\n{}", stdout);
        if !command_output.status.success() {
            let stderr = String::from_utf8_lossy(&command_output.stderr);
            println!("Command output (stderr):\n{}", stderr);
            std::process::exit(1);
        }
        // let input = open_file(file_path).unwrap();
        // let mut instance = Instance {
        //     file_name: String::from("file_name"),
        //     template_name: None,
        //     config: None,
        //     public_inputs: vec![],
        // };
        // let remaining_input =
        //     match crate::parsers::circom_parser::CircomCodeParser::new().parse(&input) {
        //         Ok(instance) => instance,
        //         Err(error) => {
        //             panic!("{}", describe_error(&input, error));
        //         }
        //     };
        // println!("ignored contents: {}", remaining_input.join("\n"));
        // let (verifier_name, code) = generate_psp_circom_code(
        //     &remaining_input.join("\n"),
        //     &String::from("signal input x;\nsignal input y;"),
        //     &mut instance,
        // )
        // .unwrap();

        // println!("{}", verifier_name);
        // println!("{}", code);
        // let file_name = "./target/test_data.circom";
        // create_file(file_name, &code).unwrap();

        // let file_name = "./target/test_data_main.circom";

        // let main_file_code = "/**
        // * This file is auto-generated by the Light cli.
        // * DO NOT EDIT MANUALLY.
        // * THE FILE WILL BE OVERWRITTEN EVERY TIME THE LIGHT CLI BUILD IS RUN.
        // */
        // pragma circom 2.1.4;
        // include \"./test_data.circom\";
        // component main {public [publicZ, transactionHash, publicAppVerifier]} =  test_data( 1, 18, 4, 4, 184598798020101492503359154328231866914977581098629757339001774613643340069, 0, 1, 3, 2, 2);";
        // create_file(file_name, &main_file_code).unwrap();

        let command_output = Command::new("circom")
            .args(&[
                "-l",
                "node_modules/circomlib/circuits/",
                "-l",
                "../light-protocol-onchain/circuit-lib/circuit-lib.circom/src/merkle-tree/",
                "target/test_data_main.circom",
                "-l",
                "../light-protocol-onchain/circuit-lib/circuit-lib.circom/src/light-utils/",
            ])
            .output()
            .expect("Failed to execute command");
        if !command_output.status.success() {
            let stderr = String::from_utf8_lossy(&command_output.stderr);
            println!("Command output (stderr):\n{}", stderr);
            std::process::exit(1);
        }
    }
}
