pub mod checkUtxo;
pub mod code_gen;
pub mod connecting_hash_circom;
pub mod errors;
pub mod ignoredContent;
pub mod instance;
pub use checkUtxo::*;

use crate::checkUtxo::generate_check_utxo_code;
use crate::errors::MacroCircomError;
use crate::{
    checkUtxo::CheckUtxo, code_gen::auto_generated_accounts::AUTO_GENERATED_ACCOUNTS_TEMPLATE,
};
use anyhow::{anyhow, Error as AnyhowError};

use errors::MacroCircomError::*;
use heck::AsLowerCamelCase;
use std::{
    env,
    fs::{self, File},
    io::{self, prelude::*},
    process::{Command, Stdio},
    thread::spawn,
};

use clap::{App, Arg};

pub fn describe_error(
    input: &str,
    error: lalrpop_util::ParseError<usize, lalrpop_util::lexer::Token<'_>, &'_ str>,
) -> String {
    match error {
        lalrpop_util::ParseError::InvalidToken { location } => {
            let start = location.saturating_sub(10);
            let end = std::cmp::min(location + 10, input.len());
            format!(
                "Invalid token near: `{}`. Full context: `{}`",
                &input[location..location + 1],
                &input[start..end]
            )
        }
        lalrpop_util::ParseError::UnrecognizedToken {
            token: (start, token, end),
            expected,
        } => {
            let context_start = start.saturating_sub(50);
            let context_end = std::cmp::min(end + 10, input.len());
            format!(
                "Unrecognized token `{}` at position {}:{} within context `{}`. Expected one of: {:?}",
                token,
                start,
                end,
                &input[context_start..context_end],
                expected
            )
        }
        lalrpop_util::ParseError::UnrecognizedEof { location, expected } => {
            let context_start = location.saturating_sub(10);
            let context_end = std::cmp::min(location + 10, input.len());
            format!(
                "Unrecognized end of file at position {}. Context: `{}`. Expected one of: {:?}",
                location,
                &input[context_start..context_end],
                expected
            )
        }
        lalrpop_util::ParseError::ExtraToken {
            token: (start, token, end),
        } => {
            let context_start = start.saturating_sub(10);
            let context_end = std::cmp::min(end + 10, input.len());
            format!(
                "Extra token `{}` at position {}:{} within context `{}`.",
                token,
                start,
                end,
                &input[context_start..context_end]
            )
        }
        lalrpop_util::ParseError::User { error } => {
            format!("User-defined error: {}", error)
        }
    }
}

const DISCLAIMER_STRING: &str = "/**
* This file is auto-generated by the Light cli.
* DO NOT EDIT MANUALLY.
* THE FILE WILL BE OVERWRITTEN EVERY TIME THE LIGHT CLI BUILD IS RUN.
*/";
#[derive(Debug, PartialEq, Clone)]
pub struct Instance {
    file_name: String,
    template_name: Option<String>,
    config: Option<Vec<String>>,
    public_inputs: Vec<String>,
}

fn parse_instance<'a>(
    input: &'a str,
    // ) -> Result<Instance, lalrpop_util::ParseError<usize, lalrpop_util::lexer::Token<'_>, &'a str>> {
) -> Instance {
    // instance::InstanceParser::new().parse(input)
    match instance::InstanceParser::new().parse(input) {
        Ok(instance) => instance,
        Err(error) => {
            panic!("{}", describe_error(&input, error));
        }
    }
}

// get instance
// - public inputs

// get utxo data
// - auto generate utxo hash code

// get light transaction
//      -expand template line
// - insert boilerplate code
// - insert utxo hash code

// Outputs:
// - circom file with circuit
// TODO: rust file with public inputs, sytem publicAppVerifier, as anchor constants

use std::path::Path;

fn remove_filename_suffix(input: &str) -> Result<(String, String), &'static str> {
    let path = Path::new(input);

    if path.extension() != Some(std::ffi::OsStr::new("light")) {
        return Err("The file does not have a .light suffix");
    }

    let directory = path
        .parent()
        .map_or(input, |p| p.to_str().unwrap_or(input))
        .to_string();
    let filename_without_suffix = path
        .file_stem()
        .map_or("", |f| f.to_str().unwrap_or(""))
        .to_string();
    println!("directory: {}", directory);
    println!("filename_without_suffix: {}", filename_without_suffix);
    Ok((directory, filename_without_suffix))
}

// throw error when no utxoData -> doesn't make sense
// throw error if is declared twice
// throw error when there is no #[instance]
// throw error when there is no #[lightTransaction(verifierTwo)]
// add test for no config inputs
/*
* Structure:
* - get instance (returns struct with file name, template name, config, public inputs)
* - get checkedUtxos (returns structs with code and utxo data)
* - get light transaction body
* - generate circom file
*/

// TODO:
// - refactor code gen into separate files

fn main() -> Result<(), AnyhowError> {
    // Take the filename from argv
    // let args: Vec<String> = env::args().collect();
    // if args.len() < 3 {
    //     eprintln!("Usage: {} <file_path>", args[0]);
    //     std::process::exit(1);
    // }
    // let file_path = &args[1];
    // let program_name = &args[2];
    let matches = App::new("macro-circom")
        .version("0.1")
        .arg(
            Arg::with_name("file_path")
                .help("Path to the file")
                .required(true)
                .index(1),
        )
        .arg(
            Arg::with_name("program_name")
                .help("Name of the program")
                .required(true)
                .index(2),
        )
        .get_matches();

    // Get the values of the arguments
    let file_path = matches.value_of("file_path").unwrap();
    let program_name = matches.value_of("program_name").unwrap();

    let (path_to_parent_dir, file_name) = remove_filename_suffix(file_path).unwrap();
    // Open the file
    let mut file = File::open(file_path).expect("Unable to open the file");

    // Read the file's content
    let mut contents = String::new();
    file.read_to_string(&mut contents)
        .expect("Unable to read the file");

    let mut instance = parse_instance(&contents);

    let (contents, checkedInUtxos) = generate_check_utxo_code(&contents)?;
    let check_utxos_code = checkedInUtxos[0].code.clone();

    let (_verifier_name, contents) =
        parse_light_transaction(&contents, &check_utxos_code, &mut instance).unwrap();

    // start code generation
    let mut output_file =
        fs::File::create(path_to_parent_dir.clone() + "/" + &file_name + ".circom").unwrap();

    write!(&mut output_file, "{}\n{}", DISCLAIMER_STRING, contents).unwrap();

    let mut output_file = fs::File::create(
        [
            &path_to_parent_dir.to_string(),
            "/",
            instance.file_name.as_str().clone(),
            &".circom",
        ]
        .concat(),
    )
    .unwrap();
    let instance_str = generate_circom_main_string(&instance, &file_name);
    println!(
        "sucessfully created main {}.circom and {}.circom",
        instance.file_name, file_name
    );

    write!(&mut output_file, "{}\n{}", DISCLAIMER_STRING, instance_str).unwrap();
    // output_file.write_all(&rustfmt(instance_str)?)?;

    // TODO: add auto generated accounts
    Ok(())
}

fn get_string_between_brackets(input: &str) -> Option<&str> {
    let start = input.find('[')?;
    let end = input.find(']')?;
    Some(&input[start + 1..end])
}

fn extract_verifier(input: &str) -> &str {
    let start_pattern = "lightTransaction(";
    let end_pattern = ")";

    let start = input.find(start_pattern).unwrap() + start_pattern.len();
    let end = input.find(end_pattern).unwrap();

    &input[start..end]
}

fn insert_string_before_parenthesis(input: &str, to_insert: &str) -> String {
    let closing_parenthesis_index = input.find(')').unwrap();
    let mut result = input[0..closing_parenthesis_index].to_string();
    result.push_str(to_insert);
    result.push_str(&input[closing_parenthesis_index..]);
    result
}

fn parse_light_transaction(
    input: &String,
    instruction_hash_code: &String,
    instance: &mut Instance,
) -> Result<(String, String), MacroCircomError> {
    let mut found_bracket = false;
    let mut remaining_lines = Vec::new();
    let mut found_instance = false;
    let mut verifier_name = String::new();

    for line in input.lines() {
        let line = line.trim();
        if line.starts_with("#[lightTransaction") {
            if found_instance == true {
                panic!();
            };
            found_instance = true;
            verifier_name = extract_verifier(line).to_string();
            found_bracket = true;
            continue;
        }

        if !found_bracket {
            remaining_lines.push(line.to_string());
        }
        if found_bracket {
            if line.starts_with("template") {
                instance.template_name = extract_template_name(line);
                let to_insert = &format!("{} nAppUtxos, levels, nIns, nOuts, feeAsset, indexFeeAsset, indexPublicAsset, nAssets, nInAssets, nOutAssets", if instance.config.is_none() || instance.config.as_ref().unwrap().is_empty() { "" } else { "," });
                remaining_lines.push(insert_string_before_parenthesis(line, to_insert));
                remaining_lines
                    .push(connecting_hash_circom::CONNECTING_HASH_VERIFIER_TWO.to_string());
                remaining_lines.push(instruction_hash_code.to_string());
                found_bracket = false;
            }
        }
    }

    if !found_instance {
        return Err(LightTransactionUndefined);
    }

    Ok((verifier_name, remaining_lines.join("\n")))
}

fn extract_template_name(input: &str) -> Option<String> {
    let start = input.find("template ")? + "template ".len();
    let end = input.find('(')?;

    Some(input[start..end].trim().to_string())
}

fn generate_circom_main_string(instance: &Instance, file_name: &str) -> String {
    let name = instance.template_name.as_ref().unwrap();
    let config = &instance.config;
    let public_inputs = instance.public_inputs.to_vec();

    let inputs_str = public_inputs.join(", ");
    let config_str = config
        .as_ref()
        .unwrap()
        .iter()
        .map(|c| c.to_string())
        .collect::<Vec<String>>()
        .join(", ");
    format!(
        "pragma circom 2.1.4;\n\
include \"./{}.circom\";\n\
component main {{public [{}]}} =  {}({}{} 18, 4, 4, 184598798020101492503359154328231866914977581098629757339001774613643340069, 0, 1, 3, 2, 2);",
         file_name, inputs_str, name, config_str, if config_str.is_empty() { "" } else { "," }
    )
}

#[allow(dead_code)]
pub fn rustfmt(code: String) -> Result<Vec<u8>, anyhow::Error> {
    let mut cmd = match env::var_os("RUSTFMT") {
        Some(r) => Command::new(r),
        None => Command::new("rustfmt"),
    };

    let mut cmd = cmd
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()?;

    let mut stdin = cmd.stdin.take().unwrap();
    let mut stdout = cmd.stdout.take().unwrap();

    let stdin_handle = spawn(move || {
        stdin.write_all(code.as_bytes()).unwrap();
        // Manually flush and close the stdin handle
        stdin.flush().unwrap();
        drop(stdin);
    });

    let mut formatted_code = vec![];
    io::copy(&mut stdout, &mut formatted_code)?;

    let _ = cmd.wait();
    stdin_handle.join().unwrap();

    Ok(formatted_code)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_instance() {
        let input = String::from(
            r#"#[instance]
            {
                fileName: appTransactionMain,
                config:(7, 1, 9, 2),
        }"#,
        );
        let initial_input = input.clone();
        let expected = Instance {
            file_name: "appTransactionMain".to_owned(),
            template_name: None,
            config: Some(vec![
                String::from("7"),
                String::from("1"),
                String::from("9"),
                String::from("2"),
            ]),
            public_inputs: vec![
                String::from("transactionHash"),
                String::from("publicAppVerifier"),
            ],
        };

        let result = instance::InstanceParser::new().parse(&input);

        match result {
            Ok(result) => assert_eq!(result, expected),
            Err(error) => {
                println!("{}", describe_error(&input, error.clone()));
                panic!("{}", describe_error(&input, error));
            }
        }
        // assert_eq!(result, expected);
        // assert_ne!(initial_input, result);
    }

    #[test]
    fn test_parse_instance_with_public_input() {
        let input = String::from(
            r#"
        // include "test.circom";
        template sxasSD {
            dsaflkjÃ§dsalnf;
        }
        #[instance]
        {
            fileName: appTransaction,
            config:(7, 1, 9, 2),
            publicInputs: [inputA,inputB],
        }
    "#,
        );
        let expected = Instance {
            file_name: "appTransaction".to_owned(),
            template_name: None,
            config: Some(vec![
                String::from("7"),
                String::from("1"),
                String::from("9"),
                String::from("2"),
            ]),
            public_inputs: vec![
                String::from("transactionHash"),
                String::from("publicAppVerifier"),
                String::from("inputA"),
                String::from("inputB"),
            ],
        };

        let result = instance::InstanceParser::new().parse(&input);

        match result {
            Ok(result) => assert_eq!(result, expected),
            Err(error) => {
                panic!("{}", describe_error(&input, error));
            }
        }
    }

    #[test]
    fn test_generate_circom_string_pass() {
        let instance = Instance {
            file_name: "appTransaction".to_owned(),
            template_name: Some(String::from("AppTransaction")),
            config: Some(vec![String::from("7"), String::from("1")]),
            public_inputs: vec![
                String::from("transactionHash"),
                String::from("publicAppVerifier"),
            ],
        };

        let expected_string = "pragma circom 2.1.4;\n\
            include \"./circuit.circom\";\n\
            component main {public [transactionHash, publicAppVerifier]} =  AppTransaction(7, 1, 18, 4, 4, 184598798020101492503359154328231866914977581098629757339001774613643340069, 0, 1, 3, 2, 2);";

        assert_eq!(
            generate_circom_main_string(&instance, "circuit"),
            expected_string
        );
    }

    #[test]
    fn test_generate_circom_string_pass2() {
        let instance = Instance {
            file_name: "appTransaction".to_owned(),
            template_name: Some(String::from("AppTransaction")),
            config: Some(vec![
                String::from("7"),
                String::from("1"),
                String::from("3"),
                String::from("2"),
            ]),
            public_inputs: vec![
                String::from("transactionHash"),
                String::from("publicAppVerifier"),
            ],
        };

        let expected_string = "pragma circom 2.1.4;\n\
            include \"./circuit.circom\";\n\
            component main {public [transactionHash, publicAppVerifier]} =  AppTransaction(7, 1, 3, 2, 18, 4, 4, 184598798020101492503359154328231866914977581098629757339001774613643340069, 0, 1, 3, 2, 2);";

        assert_eq!(
            generate_circom_main_string(&instance, "circuit"),
            expected_string
        );
    }

    #[test]
    #[should_panic(expected = "assertion failed")]
    fn test_generate_circom_string_fail() {
        let instance = Instance {
            file_name: "appTransaction".to_owned(),
            template_name: Some(String::from("AppTransaction")),
            config: Some(vec![String::from("7"), String::from("1")]),
            public_inputs: vec![
                String::from("transactionHash"),
                String::from("publicAppVerifier"),
            ],
        };

        let incorrect_expected_string = "pragma circom 2.1.4;\n\
            include \"./circuit.circom\";\n\
            component main {public [transactionHash, publicAppVerifier]} =  AppTransaction(7, 2 ,18, 4, 4, 184598798020101492503359154328231866914977581098629757339001774613643340069, 0, 1, 3, 2, 2);";

        assert_eq!(
            generate_circom_main_string(&instance, "circuit"),
            incorrect_expected_string
        );
    }

    // #[test]
    // fn test_generate_instruction_hash_code() {
    //     let input = r#"
    //     {
    //         threshold,
    //         signerPubkeysX[nr],
    //         signerPubkeysY[nr]
    //     }"#;

    //     generate_instruction_hash_code(input.to_string());
    // }
    #[test]
    fn test_extract_template_name() {
        let input = "template AppTransaction(";
        let expected = Some("AppTransaction".to_string());
        assert_eq!(expected, extract_template_name(input));

        let input = "template  AnotherTemplate \n(";
        let expected = Some("AnotherTemplate".to_string());
        assert_eq!(expected, extract_template_name(input));

        let input = "invalid format(";
        let expected: Option<String> = None;
        assert_eq!(expected, extract_template_name(input));

        let input = "template MissingParenthesis";
        let expected: Option<String> = None;
        assert_eq!(expected, extract_template_name(input));
    }

    // #[test]
    // fn test_parse_instance_no_instance_defined() {
    //     let input = String::from("no #[instance] keyword");
    //     let result = parse_instance(&input);
    //     assert_eq!(result, Err(NoInstanceDefined));
    // }

    // #[test]
    // fn test_parse_instance_too_many_instances() {
    //     let input = String::from("#[instance] {} \n#[instance] {}");
    //     let result = parse_instance(&input);
    //     assert_eq!(result, Err(TooManyInstances));
    // }

    #[test]
    fn test_parse_light_transaction_light_transaction_undefined() {
        let input = String::from("no #[lightTransaction] keyword");
        let instruction_hash_code = String::from("instruction hash code");
        let mut instance = Instance {
            file_name: String::from("file_name"),
            template_name: None,
            config: None,
            public_inputs: vec![],
        };

        let result = parse_light_transaction(&input, &instruction_hash_code, &mut instance);
        assert_eq!(result, Err(LightTransactionUndefined));
    }

    #[test]
    #[should_panic]
    fn test_parse_light_transaction_double_declaration() {
        let input = String::from(
            "#[lightTransaction(verifierOne)] { ... } \n #[lightTransaction(verifierTwo)] { ... }",
        );
        let instruction_hash_code = String::from("instruction hash code");
        let mut instance = Instance {
            file_name: String::from("file_name"),
            template_name: None,
            config: None,
            public_inputs: vec![],
        };

        let _ = parse_light_transaction(&input, &instruction_hash_code, &mut instance);
    }

    // doesn't work because the error is on the highest level
    // #[test]
    // fn test_main_invalid_number_app_utxos() {
    //     let input = "#[instance]
    //     {
    //         fileName: MockVerifierTransaction,
    //         config(),
    //         nrAppUtoxs: 1,
    //         publicInputs: [currentSlot]
    //     }

    //     #[lightTransaction(verifierTwo)]
    //     template mockVerifierTransaction() {
    //         /**
    //         * -------------------------- Application starts here --------------------------
    //         */
    //         // defines the data which is saved in the utxo
    //         // this data is defined at utxo creation
    //         // is checked that only utxos with instructionData = hash or 0
    //         // exist in input utxos
    //         // is outside instruction
    //         // could add signal inputs automatically for these
    //         // are private inputs
    //         #[utxoData]
    //         {
    //             releaseSlot
    //         }
    //         signal input currentSlot;
    //         currentSlot === releaseSlot;
    //     }"

    //     let result = main();
    //     assert_eq!(result, Err(anyhow!(InvalidNumberAppUtxos)));
    // }
    #[test]
    fn test_main() {}
}
