pragma circom 2.1.4;
include "poseidon.circom";
include "merkleProof.circom";
include "keypair.circom";
include "gates.circom";
include "comparators.circom";

// will create a new instance of the circuit
#[instance]
{
    fileName: test_data,
    // config:(1), // TODO: make work for zero inputs and make work for no config
    publicInputs: [publicZ],
}

#[checkInUtxo(dataUtxo,1,defaultInstruction)]
{
    utxoData: {
        x,
        y,
    }
}

#[lightTransaction(verifierTwo)]
template TestData() {
    // Defines the data which is saved in the utxo
    // utxoData variables need to be lowerCamelCase

    signal input publicZ;
    publicZ === x + y;
}

template otherTemplate() {
    // Defines the data which is saved in the utxo
    // utxoData variables need to be lowerCamelCase

    signal input a;
    signal input b;
    a === b;
}
/*
* Environment Constants:
*   levels = 18
*   nIns = 4 (number of in utxos)
*   nOuts = 4 (number of out utxos)
*   feeAsset = TruncatedSha256(0)
*   indexFeeAsset = 0
*   indexPublicAsset = 1
*   nAssets = 3
*   nInAssets = 2
*   nOutAssets = 2
* Environment variables:
*   txIntegrityHash;
*   transactionVersion;
*   publicAppVerifier;
*   transactionHash;
*   instructionHasher.out;
*   isAppInUtxo[nAppUtxos][nIns];
*   
*  InUtxos:
*   inAmount[nIns][nInAssets];
*   inPublicKey[nIns];
*   inBlinding[nIns];
*   inAppDataHash[nIns];
*   inPoolType[nIns];
*   inVerifierPubkey[nIns];
*   inIndices[nIns][nInAssets][nAssets];
* OutUtxos:
*   outputCommitment[nOuts];
*   outAmount[nOuts][nOutAssets];
*   outPubkey[nOuts];
*   outBlinding[nOuts];
*   outAppDataHash[nOuts];
*   outIndices[nOuts][nOutAssets][nAssets];
*   outPoolType[nOuts];
*   outVerifierPubkey[nOuts];
*/